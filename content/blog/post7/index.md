---
title: 쿠키, 세션, 토큰(JWT)
date: "2022-06-16T22:12:03.284Z"
---
- **쿠키, 세션, 토큰의 필요성**
  - `HTTP`란 인터넷 상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜을 말한다. `HTTP`는 **비연결성 및 무상태성**이라는 특징을 가지고 있는데 이는 서버의 자원 낭비를 줄일 수 있다는 장점을 가지고 있으나, **로그인 이후 다음 요청에서 해당 클라이언트를 기억하지 못하는 현상 때문에 로그인을 유지하지 못하는 상황**이 발생한다. 이와 같은 **문제점을 해결하기 위해 `쿠키(Cookie)`와 `세션(Session)`이라는 기능을 사용**하게된다.

- **쿠키 (Cookie)**
  - 클라이언트가 어떠한 웹사이트를 방문하는 경우 사이트가 사용되고 있는 **서버를 통해 클라이언트 브라우저에 설치되는 작은 기록 파일**을 일컫는다.
  - 서버는 클라이언트의 **로그인 요청**에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 `ResponseHeader`의 `Set-Cookie`에 담는다. (`Cookie`는 `Key-Value`형식의 문자열이다.) 이후 해당 클라이언트는 요청을 보낼 때마다 매번 저장된 `Cookie`를 `RequestHeader`의 `Cookie`에 담아 보낸다. 서버는 `Cookie`에 담긴 정보를 바탕으로 해당 요청의 **클라이언트가 누군지 식별할 수 있다.**
  - **단점**
    - 보안에 취약(요청 시 `Cookie`의 값을 그대로 보내어, 유출 및 조작 당할 위험이 존재)
    - 용량 제한이 있어, 많은 정보를 담을 수 없다.
    - 브라우저마다 `Cookie`에 대한 지원 형태가 다르기에, 브라우저 간 공유가 불가능하다.
    - `Cookie` 사이즈가 커질수록 네트워크에 부하가 생긴다.

- **세션 (Session)**
  - `Session`은 클라이언트의 인증 정보를 `Cookie`가 아닌 서버 측에 저장하고 관리한다.
  - 서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 인증 정보는 서버에 저장하고 클라이언트 식별자인 `JSESSIONID`를 `Cookie`에 담는다. 이후 클라이언트는 요청을 보낼 때 마다 `JSESSIONID` 가 저장 된 `Cookie`를 함께 보낸다. 서버는 `JSSESIONID`의 유효성을 판별해 클라이언트를 식별한다
  - 장점
    - 서버가 클라이언트의 웹 브라우저에 의존하지 않아도 된다.
    - 쿠키를 포함한 요청이 외부에 노출되어도 `Session`ID 자체는 유의미한 개인 정보를 담지 않는다.
    - 각 사용자마다 고유한 `Session`ID가 발급되기 때문에 요청이 들어올 때마다 회원 정보를 확인 할 필요가 없다.
  - 단점
    - 해커가 `Session` ID를 중간에 탈취하여 클라이언트인 척 위장할 수 있다.
    - 서버에서 `Session`저장소를 사용하기 때문에, 요청이 많아지면 서버에 부하가 생긴다.

- **토큰 (Token)**
  - `JWT(JSON Web Token)`은 인증에 필요한 정보를을 암호화시킨 토큰을 말한다.
  - `JWT(JSON Web Token)` 기반 인증은 쿠키/세션 방식과 유사하게`JTW Token`을 `HTTP-Header`에 실어 서버가 클라이언트를 식별한다
  - `JWT(JSON Web Token)`의 구조는 세가지 문자열의 조합이다. 실제 디코딩된 `JWT(JSON Web Token)`은 `Header`, `Payload`, `Signature`로 이루어져 있다.

  - **Header**
    - `Header`는 `alg`와 `typ`을 갖고 있다.`alg`는 정보를 암호화할 해싱 알고리즘을, `typ`는 토큰의 타입을 지정한다.

    ```
    {
    	"alg": "HS256",
    	"typ": "JWT"
    }
    ```

  - **Payload**
    - `Payload`는 실제로 토큰에 담을 정보를 지니고 있다.주로 `클라이언트 고유 ID`, `유효 기간` 등이 포함된다.`Key-Value` 형식으로 이루어진 한 쌍의 정보를 `Claim`이라고 한다.

    ```
    {
    	"sub": "1234567890",
    	"name": "John Doe",
    	"iat": 1516230922
    }
    ```

  - **Signature**
    - `Signature`는 인코딩된 `Header`와 `Payload`를 더한 뒤, 비밀키로 해싱하여 생성한다.

      `Header` 및 `Payload`는 단순 인코딩된 값이기 때문에 해커가 복호화하고 조작할 수 있지만, `Signature`는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.

      따라서 `Signature`는 토큰의 **위변조 여부를 확인**하는 데 사용된다.

    ```

    HMACSHA256(
    	base64UrlEncode(header) + "." +
    	base64UrlEncode(payload),
    	secret_key
    )

    ```
    
  - **토큰 인증 과정**
      1. 클라이언트 로그인 요청이 들어오면, 서버는 검증 후 클라이언트 고유 ID등의 정보를 `Payload`에 담는다.
      2. 암호화할 비밀키를 사용해 `Access Token(JWT)`을 발급한다.
      3. 클라이언트는 전달받은 토큰을 저장해두고, 서버에 요청할 때마다 토큰을 요청 헤더 `Authorization`에 포함시켜 함께 전달한다.
      4. 서버는 토큰의 `Signature` 을 비밀키로 복호화한 다음, `위변조 여부` 및 `유효 기간` 등을 확인한다.
      5. 유효한 토큰이라면 요청에 응답한다.
  - **장점**
      - `Header`와 `Payload`를 가지고 `Signature`를 생성하므로 데이터 위변조를 막을 수 있다.
      - 인증 정보에 대한 **별도의 저장소가 필요 없다**. (I/O 처리 필요 없음)
      - JWT는 `토큰에 대한 기본 정보`와 `전달할 정보` 및 `토큰이 검증됐음을 증명하는 서명` 등 필요한 모든 정보를 자체적으로 지니고 있다.
      - 클라이언트의 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(Stateless)가 된다.
      - 확장성이 우수하다.
      - 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (토큰 서버 활용)
      - 토큰 기반으로 다른 로그인 시스템에 `접근` 및 `권한 공유`가 가능하다.
      - `OAuth`의 경우 Facebook, Google 등 소셜 계정을 이용해 다른 웹서비스에서도 로그인 할 수 있다.
      - 모바일 어플리케이션 환경에서도 잘 동작한다.
  - **단점**
      - `쿠키`, `세션`과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많을수록 네트워크 부하가 심해진다.
      - `Payload` 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다. (패스워드 등)
      - 토큰을 탈취당하면 대처하기 어렵다. 토큰은 한 번 발급되면 유효기간이 만료될 때까지 계속 사용이 가능하다.
      - 특정 사용자의 접속을 강제로 만료하기 어렵다. (쿠키/세션 기반 인증은 서버 단에서 쉽게 삭제할 수 있지만 토큰은 그게 안 됨)