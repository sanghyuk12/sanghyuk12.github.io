{"componentChunkName":"component---src-templates-blog-post-js","path":"/post7/","result":{"data":{"site":{"siteMetadata":{"title":"HYUK's SoftWare"}},"markdownRemark":{"id":"41268b05-e194-5398-8475-0fec22547808","excerpt":"…","html":"<ul>\n<li>\n<p><strong>쿠키, 세션, 토큰의 필요성</strong></p>\n<ul>\n<li><code class=\"language-text\">HTTP</code>란 인터넷 상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜을 말한다. <code class=\"language-text\">HTTP</code>는 <strong>비연결성 및 무상태성</strong>이라는 특징을 가지고 있는데 이는 서버의 자원 낭비를 줄일 수 있다는 장점을 가지고 있으나, <strong>로그인 이후 다음 요청에서 해당 클라이언트를 기억하지 못하는 현상 때문에 로그인을 유지하지 못하는 상황</strong>이 발생한다. 이와 같은 <strong>문제점을 해결하기 위해 <code class=\"language-text\">쿠키(Cookie)</code>와 <code class=\"language-text\">세션(Session)</code>이라는 기능을 사용</strong>하게된다.</li>\n</ul>\n</li>\n<li>\n<p><strong>쿠키 (Cookie)</strong></p>\n<ul>\n<li>클라이언트가 어떠한 웹사이트를 방문하는 경우 사이트가 사용되고 있는 <strong>서버를 통해 클라이언트 브라우저에 설치되는 작은 기록 파일</strong>을 일컫는다.</li>\n<li>서버는 클라이언트의 <strong>로그인 요청</strong>에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 <code class=\"language-text\">ResponseHeader</code>의 <code class=\"language-text\">Set-Cookie</code>에 담는다. (<code class=\"language-text\">Cookie</code>는 <code class=\"language-text\">Key-Value</code>형식의 문자열이다.) 이후 해당 클라이언트는 요청을 보낼 때마다 매번 저장된 <code class=\"language-text\">Cookie</code>를 <code class=\"language-text\">RequestHeader</code>의 <code class=\"language-text\">Cookie</code>에 담아 보낸다. 서버는 <code class=\"language-text\">Cookie</code>에 담긴 정보를 바탕으로 해당 요청의 <strong>클라이언트가 누군지 식별할 수 있다.</strong></li>\n<li><strong>단점</strong>\n<ul>\n<li>보안에 취약(요청 시 <code class=\"language-text\">Cookie</code>의 값을 그대로 보내어, 유출 및 조작 당할 위험이 존재)</li>\n<li>용량 제한이 있어, 많은 정보를 담을 수 없다.</li>\n<li>브라우저마다 <code class=\"language-text\">Cookie</code>에 대한 지원 형태가 다르기에, 브라우저 간 공유가 불가능하다.</li>\n<li><code class=\"language-text\">Cookie</code> 사이즈가 커질수록 네트워크에 부하가 생긴다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>세션 (Session)</strong></p>\n<ul>\n<li><code class=\"language-text\">Session</code>은 클라이언트의 인증 정보를 <code class=\"language-text\">Cookie</code>가 아닌 서버 측에 저장하고 관리한다.</li>\n<li>서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 인증 정보는 서버에 저장하고 클라이언트 식별자인 <code class=\"language-text\">JSESSIONID</code>를 <code class=\"language-text\">Cookie</code>에 담는다. 이후 클라이언트는 요청을 보낼 때 마다 <code class=\"language-text\">JSESSIONID</code> 가 저장 된 <code class=\"language-text\">Cookie</code>를 함께 보낸다. 서버는 <code class=\"language-text\">JSSESIONID</code>의 유효성을 판별해 클라이언트를 식별한다</li>\n<li>장점\n<ul>\n<li>서버가 클라이언트의 웹 브라우저에 의존하지 않아도 된다.</li>\n<li>쿠키를 포함한 요청이 외부에 노출되어도 <code class=\"language-text\">Session</code>ID 자체는 유의미한 개인 정보를 담지 않는다.</li>\n<li>각 사용자마다 고유한 <code class=\"language-text\">Session</code>ID가 발급되기 때문에 요청이 들어올 때마다 회원 정보를 확인 할 필요가 없다.</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>해커가 <code class=\"language-text\">Session</code> ID를 중간에 탈취하여 클라이언트인 척 위장할 수 있다.</li>\n<li>서버에서 <code class=\"language-text\">Session</code>저장소를 사용하기 때문에, 요청이 많아지면 서버에 부하가 생긴다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>토큰 (Token)</strong></p>\n<ul>\n<li>\n<p><code class=\"language-text\">JWT(JSON Web Token)</code>은 인증에 필요한 정보를을 암호화시킨 토큰을 말한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">JWT(JSON Web Token)</code> 기반 인증은 쿠키/세션 방식과 유사하게<code class=\"language-text\">JTW Token</code>을 <code class=\"language-text\">HTTP-Header</code>에 실어 서버가 클라이언트를 식별한다</p>\n</li>\n<li>\n<p><code class=\"language-text\">JWT(JSON Web Token)</code>의 구조는 세가지 문자열의 조합이다. 실제 디코딩된 <code class=\"language-text\">JWT(JSON Web Token)</code>은 <code class=\"language-text\">Header</code>, <code class=\"language-text\">Payload</code>, <code class=\"language-text\">Signature</code>로 이루어져 있다.</p>\n</li>\n<li>\n<p><strong>Header</strong></p>\n<ul>\n<li><code class=\"language-text\">Header</code>는 <code class=\"language-text\">alg</code>와 <code class=\"language-text\">typ</code>을 갖고 있다.<code class=\"language-text\">alg</code>는 정보를 암호화할 해싱 알고리즘을, <code class=\"language-text\">typ</code>는 토큰의 타입을 지정한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\r\n\t\"alg\": \"HS256\",\r\n\t\"typ\": \"JWT\"\r\n}</code></pre></div>\n</li>\n<li>\n<p><strong>Payload</strong></p>\n<ul>\n<li><code class=\"language-text\">Payload</code>는 실제로 토큰에 담을 정보를 지니고 있다.주로 <code class=\"language-text\">클라이언트 고유 ID</code>, <code class=\"language-text\">유효 기간</code> 등이 포함된다.<code class=\"language-text\">Key-Value</code> 형식으로 이루어진 한 쌍의 정보를 <code class=\"language-text\">Claim</code>이라고 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\r\n\t\"sub\": \"1234567890\",\r\n\t\"name\": \"John Doe\",\r\n\t\"iat\": 1516230922\r\n}</code></pre></div>\n</li>\n<li>\n<p><strong>Signature</strong></p>\n<ul>\n<li>\n<p><code class=\"language-text\">Signature</code>는 인코딩된 <code class=\"language-text\">Header</code>와 <code class=\"language-text\">Payload</code>를 더한 뒤, 비밀키로 해싱하여 생성한다.</p>\n<p><code class=\"language-text\">Header</code> 및 <code class=\"language-text\">Payload</code>는 단순 인코딩된 값이기 때문에 해커가 복호화하고 조작할 수 있지만, <code class=\"language-text\">Signature</code>는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.</p>\n<p>따라서 <code class=\"language-text\">Signature</code>는 토큰의 <strong>위변조 여부를 확인</strong>하는 데 사용된다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\r\nHMACSHA256(\r\n\tbase64UrlEncode(header) + \".\" +\r\n\tbase64UrlEncode(payload),\r\n\tsecret_key\r\n)\r\n</code></pre></div>\n</li>\n<li>\n<p><strong>토큰 인증 과정</strong></p>\n<ol>\n<li>클라이언트 로그인 요청이 들어오면, 서버는 검증 후 클라이언트 고유 ID등의 정보를 <code class=\"language-text\">Payload</code>에 담는다.</li>\n<li>암호화할 비밀키를 사용해 <code class=\"language-text\">Access Token(JWT)</code>을 발급한다.</li>\n<li>클라이언트는 전달받은 토큰을 저장해두고, 서버에 요청할 때마다 토큰을 요청 헤더 <code class=\"language-text\">Authorization</code>에 포함시켜 함께 전달한다.</li>\n<li>서버는 토큰의 <code class=\"language-text\">Signature</code> 을 비밀키로 복호화한 다음, <code class=\"language-text\">위변조 여부</code> 및 <code class=\"language-text\">유효 기간</code> 등을 확인한다.</li>\n<li>유효한 토큰이라면 요청에 응답한다.</li>\n</ol>\n</li>\n<li>\n<p><strong>장점</strong></p>\n<ul>\n<li><code class=\"language-text\">Header</code>와 <code class=\"language-text\">Payload</code>를 가지고 <code class=\"language-text\">Signature</code>를 생성하므로 데이터 위변조를 막을 수 있다.</li>\n<li>인증 정보에 대한 <strong>별도의 저장소가 필요 없다</strong>. (I/O 처리 필요 없음)</li>\n<li>JWT는 <code class=\"language-text\">토큰에 대한 기본 정보</code>와 <code class=\"language-text\">전달할 정보</code> 및 <code class=\"language-text\">토큰이 검증됐음을 증명하는 서명</code> 등 필요한 모든 정보를 자체적으로 지니고 있다.</li>\n<li>클라이언트의 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(Stateless)가 된다.</li>\n<li>확장성이 우수하다.</li>\n<li>토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (토큰 서버 활용)</li>\n<li>토큰 기반으로 다른 로그인 시스템에 <code class=\"language-text\">접근</code> 및 <code class=\"language-text\">권한 공유</code>가 가능하다.</li>\n<li><code class=\"language-text\">OAuth</code>의 경우 Facebook, Google 등 소셜 계정을 이용해 다른 웹서비스에서도 로그인 할 수 있다.</li>\n<li>모바일 어플리케이션 환경에서도 잘 동작한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>단점</strong></p>\n<ul>\n<li><code class=\"language-text\">쿠키</code>, <code class=\"language-text\">세션</code>과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많을수록 네트워크 부하가 심해진다.</li>\n<li><code class=\"language-text\">Payload</code> 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다. (패스워드 등)</li>\n<li>토큰을 탈취당하면 대처하기 어렵다. 토큰은 한 번 발급되면 유효기간이 만료될 때까지 계속 사용이 가능하다.</li>\n<li>특정 사용자의 접속을 강제로 만료하기 어렵다. (쿠키/세션 기반 인증은 서버 단에서 쉽게 삭제할 수 있지만 토큰은 그게 안 됨)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"쿠키, 세션, 토큰(JWT)","date":"June 16, 2022","description":null}},"previous":{"fields":{"slug":"/post6/"},"frontmatter":{"title":"Spring Annotaion"}},"next":null},"pageContext":{"id":"41268b05-e194-5398-8475-0fec22547808","previousPostId":"c1f83ed3-ea04-557d-964f-49ffa182365a","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}