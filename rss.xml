<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[Gatsby Starter Blog RSS Feed]]></description><link>https://github.com/sanghyuk12</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 16 Aug 2022 04:54:43 GMT</lastBuildDate><item><title><![CDATA[CORS(Cross-Origin Resource Sharing )]]></title><description><![CDATA[…]]></description><link>https://github.com/sanghyuk12/post4/</link><guid isPermaLink="false">https://github.com/sanghyuk12/post4/</guid><pubDate>Mon, 13 Jun 2022 22:12:03 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;브라우저의 동일 근원 정책에 의해 생겨난 타 도메인 간에 자원을 공유할 수 있게 해주는 것&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동일근원 정책이란 ?&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 &lt;code class=&quot;language-text&quot;&gt;cross-origin HTTP&lt;/code&gt; 요청에 의해 요청되나 대부분의 브라우저들은 보안상의 이유로 스크립트에서 &lt;code class=&quot;language-text&quot;&gt;cross-origin HTTP&lt;/code&gt; 요청을 제한한다. 이것을 &lt;code class=&quot;language-text&quot;&gt;Same-Origin-Policy&lt;/code&gt;(동일 근원 정책)이라고 한다. 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜 및 포트가 같아야 함을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;해결방안&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;과거에는 flash를 proxy로 두고 타 도메인간 통신을 했으나 모바일 운영체제(IOS에서는 flash자체를 지원하지 않음)의 등장으로 제한&lt;/li&gt;
&lt;li&gt;JSONP(json-padding)
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;JSONP&lt;/code&gt;란 jQuery v1.2이상 부터 지원되며, ajax호출 시 타 도메인 간에 호출이 가능 하게 해준다. 타 도메인간 자원 공유할 수 있는 몇가지 태그가 존재하는데 예를 들면 &lt;code class=&quot;language-text&quot;&gt;img&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;iframe&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;anchor&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;link&lt;/code&gt; 등이 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Preflight Request(request.setHeader())
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;실제 요청을 보내도 안전한지 판단하기 위해 &lt;code class=&quot;language-text&quot;&gt;preflight&lt;/code&gt; 요청을 먼저 보내는 방법, 실제 요청 전에 인증 헤더를 전송하여 서버의 허용 여부를 미리 체크하는 테스트 요청 이 요청으로 인해 트래픽이 증가할 수 있는데 서버의 헤더 설정으로 캐쉬가 가능 HTTP의 &lt;code class=&quot;language-text&quot;&gt;OPTIONS&lt;/code&gt; 메서드를 사용하며 &lt;code class=&quot;language-text&quot;&gt;Access-Control-Request&lt;/code&gt; 형태의 헤더로 전송함으로 써 브라우저가 해당 도메인에서 CORS를 허용하는지 알 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP Header&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code class=&quot;language-text&quot;&gt;Description&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Origin&lt;/td&gt;
&lt;td&gt;접근 가능한 url 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Credentials&lt;/td&gt;
&lt;td&gt;접근 가능한 쿠키 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Headers&lt;/td&gt;
&lt;td&gt;접근 가능한 헤더 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access-Control-Allow-Methods&lt;/td&gt;
&lt;td&gt;접근 가능한 http method 설정&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST API를 통한 처리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트에서 바로 처리하지 않고 서버 단에서 &lt;code class=&quot;language-text&quot;&gt;REST API&lt;/code&gt;를 활용해 서버간에 응답 데이터를 받아와 클라이언트에 데이터를 전달해 주는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[브라우저 동작원리]]></title><description><![CDATA[CSS 마크업 처리 후 CSSOM 트리 빌드(어떻게) CSS에서 CSSOM으로  HTML을 파싱하다 CSS링크를 만나면, CSS파일을 요청해서 받아온다. 받아온 CSS파일은 HTML을 파싱한 것과 유사한 과정을 거쳐 역시 Tree형태의 CSSOM…]]></description><link>https://github.com/sanghyuk12/post3/</link><guid isPermaLink="false">https://github.com/sanghyuk12/post3/</guid><pubDate>Sun, 12 Jun 2022 22:12:03 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CSS 마크업 처리 후 CSSOM 트리 빌드(어떻게)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CSS에서 CSSOM으로&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d907261d6d25a1cb6f8040ae00e1e4d9/17a7a/post3_1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 24.68354430379747%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAx0lEQVQY042QWW7DMAxEff8rNrDbOnVsCUW0eYks8RWSkyDtVwkMwBFnSJENj5A7HlReyKvmD3/q7v4m50xOub7NYUZNiq7tsMZWwR53ckpIEiQLt+125EmeTYq/1ErzxlpL/9mjlUaNmmlUqEkTfMAag3cz08XQtS3v3QentxPjZeTcnw/PpBi+hooYI02Z6KwjeI8zCXelYgmgx4Qa4FtFrLnWX5ct1mU9PC7U3Dtfa2lPNL9OkmFbhHUW0i5sKyxeyDv/jh9he4UlJql2KQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;post3_1&quot;
        title=&quot;post3_1&quot;
        src=&quot;/static/d907261d6d25a1cb6f8040ae00e1e4d9/f058b/post3_1.png&quot;
        srcset=&quot;/static/d907261d6d25a1cb6f8040ae00e1e4d9/c26ae/post3_1.png 158w,
/static/d907261d6d25a1cb6f8040ae00e1e4d9/6bdcf/post3_1.png 315w,
/static/d907261d6d25a1cb6f8040ae00e1e4d9/f058b/post3_1.png 630w,
/static/d907261d6d25a1cb6f8040ae00e1e4d9/17a7a/post3_1.png 753w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML을 파싱하다 CSS링크를 만나면, CSS파일을 요청해서 받아온다. 받아온 CSS파일은 HTML을 파싱한 것과 유사한 과정을 거쳐 역시 Tree형태의 CSSOM으로 만들어 진다. CSS 파싱은 CSS 특성상 자식 노드들이 부모 노드의 특성을 계속해서 이어받는(cascading) 규칙이 추가되는 것을 빼고는 HTML 파싱과 동일하게 이루어진다. 이렇게 CSSOM을 구성하는 것이 끝나야 이후의 Rendering 과정을 시작할 수 있기 때문에 CSS는 redering의 blocking 요소라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DOM, CSSOM 을 결합하여 렌더링 트리 형성(화면에 그려질 것 결정)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/67be8b3167b174a6fd238856616d89c5/ae694/post3_2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 22.78481012658228%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVQY032Q226DMBBE+f9PTFUCAYdwC5fgGxhO5S1N1ZeuNJLPejUaTcKBzLZueOcJW6Bru+9l/DxOnfje/XDE/ZeTCFHDcyDPcrL0SlnccYa3VgfWeDgCVoO34J1lD7soGlljxSdJP1PqRy2pmrph6J9Y48TA2Y3lZairgUd5oPKAyuChNEoVZNeMW36j73rKopRASUymFy2GqlTUVU3btNyVkoOPy4VKNZgXLPOBnmPCgNGacRiZxkmqih6Rk7MsiT5PsxwYbXDWyTserX7lT2n/zBdpvYJ1aIbhUwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;post3_2&quot;
        title=&quot;post3_2&quot;
        src=&quot;/static/67be8b3167b174a6fd238856616d89c5/f058b/post3_2.png&quot;
        srcset=&quot;/static/67be8b3167b174a6fd238856616d89c5/c26ae/post3_2.png 158w,
/static/67be8b3167b174a6fd238856616d89c5/6bdcf/post3_2.png 315w,
/static/67be8b3167b174a6fd238856616d89c5/f058b/post3_2.png 630w,
/static/67be8b3167b174a6fd238856616d89c5/ae694/post3_2.png 850w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DOM(Content) CSSOM(Style) = Render Tree&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 과 CSSOM을 합쳐 Render Tree가 만들어지게 되는데. Render Tree는 화면에 실제 보이는 내용들로만 이루어 진다. 만약 CSS에서 display: none으로 설정했다면, 그 노드(자식 노드 포함)는 Render Tree에 추가되지 않는다. 마찬가지로 &lt;header&gt; 태그 안의 내용들도 Render Tree에는 포함되지 않는다. 그래서 아래 그림처럼 Render Tree에서는 &lt;header&gt;태그와 속성이 display: none인 &lt;span&gt;태그는 제외된 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/e7e9c1b94869596c21a62dab99c8bc1b/13e20/post3_3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 48.10126582278481%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB2ElEQVQoz3WSW4/TMBCF8+v5GbzsCy+8gsRFIASIh1W1alXabHfTJm1zvzupkzjOh5K2uywSRxrb8ljHM+eMATAAUsrzaRjo2xytaqbcoKd7rfvnNxcMw3AJPe0jjHGpC4cgjNEDtBrs5RvS4w/+RpwWrO8fEXJAqZZTbvEvRlIjj9YcVzck/h1KddTCx999pcp39EBTR/RdQVKciFNBFEfE/gJ/+4Es3iCloCocVBOeK0ycT1TFDs/6zN718DZvSY4/iUuI8xZneUPifERICNIW310TmK8pRIm5eM9hb7LbfMe2bun6S8sjTi2EWcd2d4+5/ILtZuSioU5/I4XDwc8xN1usQ8r96huPlontlgTJiWNYYx9TZNtjjG12XXcRXuNFAi+qaDs1fTTqOsagz+aMWpqWhxeVKKUms7RW6L6f8sYoZNM0eJ5HmqZPAudFNWlWt5DlgqIsmTjP8tP3ik51E+k1JlOmKrSmqirapqU81VjugcX2SJzlZP4MUbiTPvKUUCd3DL3kfzCu83OFHQXcmjOWzh7bDXAf3uHsN1QNlPGc/ewVQgS4aYITHhBN82ImjZcD+kw+thcmFcXoblKTlS2djKnCXxRVydzeMN+uKKV8Ihwr/ANhg/1I0ifvLwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;post3_3&quot;
        title=&quot;post3_3&quot;
        src=&quot;/static/e7e9c1b94869596c21a62dab99c8bc1b/f058b/post3_3.png&quot;
        srcset=&quot;/static/e7e9c1b94869596c21a62dab99c8bc1b/c26ae/post3_3.png 158w,
/static/e7e9c1b94869596c21a62dab99c8bc1b/6bdcf/post3_3.png 315w,
/static/e7e9c1b94869596c21a62dab99c8bc1b/f058b/post3_3.png 630w,
/static/e7e9c1b94869596c21a62dab99c8bc1b/13e20/post3_3.png 741w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;strong&gt;렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태 계산(Box-Model 생성)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Layout(reflow)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d1927e722aa363bec626a0d87dee7471/d0cc0/post3_4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 25.949367088607595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAzUlEQVQY01WQjY6CMBCEef831BNBAdGriMeVQn8/0+J5MMkmO83spDMZQPBhmRAixVmHMYYNwqL72z98tcf7zDv/uZG/krqqqc81neiSsZ411ti0R8xqxllL8AuPRmuPTAjBMT9SnSue/TMZiptglGPi/aNPb/kh52t/YL/bcb08uDUe0ULfDZRFwak8JX1mtEEOEjWqf8NvwV3caeqGsihpL236/fAzMKkJazzTCJOM9XgmpZKH1ppsU5MPKWIc51yKGkXrSJtSeXe4wgtGcoPbkhjw2wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;post3_4&quot;
        title=&quot;post3_4&quot;
        src=&quot;/static/d1927e722aa363bec626a0d87dee7471/f058b/post3_4.png&quot;
        srcset=&quot;/static/d1927e722aa363bec626a0d87dee7471/c26ae/post3_4.png 158w,
/static/d1927e722aa363bec626a0d87dee7471/6bdcf/post3_4.png 315w,
/static/d1927e722aa363bec626a0d87dee7471/f058b/post3_4.png 630w,
/static/d1927e722aa363bec626a0d87dee7471/d0cc0/post3_4.png 732w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Render Tree가 다 만들어지면, Render Tree에 있는 각각의 노드들이 화면의 어디에 위치할 지를 계산하는 Layout과정을 거친다. CSSOM에서 가져온 스타일 정보들로 어떻게 생겨야 한다는 것을 알고 있지만, 실제로 놓으려면 어디에 가야하는지 계산하는 과정을 위해 CSS box model이 쓰이며, position, width, height 등등 틀과 위치에 관련된 부분들을 통해 계산해서 그리게 되는데 이 과정을 Webkit에서는 layout, Gecko에서는 reflow로 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;strong&gt;개별 노드를 화면에 페인트.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paint(repaint)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b5cb8bccf5088a3861b0e9ad0dde38bc/cecac/post3_5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 25.949367088607595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAxklEQVQY031Qi26DMAzk//9wohrl0QoCLVUIJMbEN9lrpWqbZunkOPFdzi7wCvmGiFhOMeFXyB+1vJ8FxcEHeGdIFlAk1FWNc3XGpbtA3ygRdtota734xWpFPrLxmBiZBZKBwntvAk3dYL7PGPoBt+mGNax4zA+DilefFU7lCeVHia7t0DatfT46h3GIcFdgnp4Ot3UzhCUY2Q0O0zihv/YmpALqTHviFs2p5uCDOT0YSJtOKCh+7oSIkFIy0mtkZv5/l28XXxSAg8nAJjujAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;post3_5&quot;
        title=&quot;post3_5&quot;
        src=&quot;/static/b5cb8bccf5088a3861b0e9ad0dde38bc/f058b/post3_5.png&quot;
        srcset=&quot;/static/b5cb8bccf5088a3861b0e9ad0dde38bc/c26ae/post3_5.png 158w,
/static/b5cb8bccf5088a3861b0e9ad0dde38bc/6bdcf/post3_5.png 315w,
/static/b5cb8bccf5088a3861b0e9ad0dde38bc/f058b/post3_5.png 630w,
/static/b5cb8bccf5088a3861b0e9ad0dde38bc/cecac/post3_5.png 728w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Render Tree의 각 노드들을 실제로 화면에 그림(정말로 눈에 보이는 픽셀들 visibility, outline, background-color)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[멀티 스레드]]></title><description><![CDATA[…]]></description><link>https://github.com/sanghyuk12/post2/</link><guid isPermaLink="false">https://github.com/sanghyuk12/post2/</guid><pubDate>Sat, 11 Jun 2022 22:12:03 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;멀티 스레딩의 장점&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;프로세스를 이용하여 동시에 처리하던 일을 &lt;strong&gt;스레드로 구현할 경우 메모리 공간과 시스템 자원 감소가 줄어들게 된다.&lt;/strong&gt; 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 &lt;strong&gt;전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고받을 수 있다.&lt;/strong&gt; 그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신방법이 더 간단하다. &lt;strong&gt;context swtich 또한&lt;/strong&gt; 스레드가 프로세스와 달리 &lt;strong&gt;캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.&lt;/strong&gt; 따라서 시스템의 &lt;strong&gt;throughput 이 향상되고 자원 소모가 줄어들며&lt;/strong&gt; 자연스럽게 &lt;strong&gt;프로그램의 응답 시간이 단축&lt;/strong&gt;된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티 스레딩의 문제점&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;멀티 프로세스 기반으로 프로그래밍 시에는 프로세스간 공유하는 자원이 없기 때문에 &lt;strong&gt;동일한 자원에 동시에 접근하는일&lt;/strong&gt;이 없지만 멀티 스레딩 기반으로 프로그래밍할 때는 &lt;strong&gt;이 부분을 신경 써줘야 한다.&lt;/strong&gt; 서로 다른 스레드가 &lt;strong&gt;데이터와 힙영역을 공유하기 때문&lt;/strong&gt;에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 그렇기 때문에 &lt;strong&gt;멀티스레딩 환경에서는 동기화 작업&lt;/strong&gt;이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤한다. 하지만 &lt;strong&gt;이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;멀티 스레드 vs 멀티 프로세스&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;멀티 스레드는 멀티 프로세스보다 적은 &lt;strong&gt;메모리 공간을 차지하고 문맥 전환이 빠르다.&lt;/strong&gt; 하지만 오류로 인해 &lt;strong&gt;하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다&lt;/strong&gt;는 점과 &lt;strong&gt;동기화 문제&lt;/strong&gt;를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이존재한다. 따라서 &lt;strong&gt;대상 시스템의 적합한 동작 방식을 선택&lt;/strong&gt;하고 적용해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[프로세스와 스레드의 차이]]></title><description><![CDATA[프로세스 (Process) 프로세스란 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU…]]></description><link>https://github.com/sanghyuk12/post1/</link><guid isPermaLink="false">https://github.com/sanghyuk12/post1/</guid><pubDate>Fri, 10 Jun 2022 22:12:03 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;프로세스 (Process)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스란 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다.&lt;/strong&gt; 운영체제로부터 주소 공간, 파일, 메모리 등을 할당 받으며 이것들을 총칭하여 프로세스라고 한다. 프로세스는 함수의 매개변수, 복귀 주소, 로컬 변수와 같은 임시 자료를 갖는 &lt;strong&gt;프로세스 스택과&lt;/strong&gt; 전역 변수들을 수록하는 &lt;strong&gt;데이터 섹션&lt;/strong&gt;을 포함한다. 또한 프로세스 실행 중에 &lt;strong&gt;동적으로 할당되는 메모리인 힙을 포함&lt;/strong&gt;한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로세스 제어 블록(Process Control Block, PCB)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PBC&lt;/strong&gt; 는 특정 &lt;strong&gt;프로세스에 대한 중요한 정보를 저장 하고 있는 운영체제의 자료구조&lt;/strong&gt;이다. 운영체제는 프로세스를 관리하기 위해 프로세스 생성과 동시에 고유한 PCB를 생성 한다 &lt;strong&gt;프로세스는&lt;/strong&gt; CPU 를 할당 받아 작업을 처리하다가도 &lt;strong&gt;프로세스 전환이 발생하면&lt;/strong&gt; 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 &lt;strong&gt;작업의 진행 상황 모두 PCB에 저장&lt;/strong&gt;하게 된다 그리고 &lt;strong&gt;다시 CPU 를 할당 받게 되면&lt;/strong&gt; &lt;strong&gt;PCB에 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행&lt;/strong&gt;한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PCB에 저장되는 정보&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스 식별자(ProcessID, PID): 프로세스 식별번호&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로세스 상태: new, ready, running, waiting, terminated 등의 상태 저장&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 레지스터&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 스케쥴링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;어카운팅 정보: 사용된 CPU 시간, 시간제한, 계정정보 등&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;스레드 (Thread)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;스레드란 프로세스의 실행 단위&lt;/strong&gt;라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소공간이나 자원을 공유할 수 있다. 스레드는 &lt;strong&gt;스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성&lt;/strong&gt;된다. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다. &lt;strong&gt;하나의 프로세스를 다수의 스레드로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩&lt;/strong&gt;이라고 한다. 이 경우 각각의 &lt;strong&gt;스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터&lt;/strong&gt; 값을 갖고 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스택을 스레드 마다 독립적으로 할당하는 이유&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 &lt;strong&gt;독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당&lt;/strong&gt;한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PC Register를 스레드마다 독립적으로 할당하는 이유&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;PC 값은 스레드가 명령어 어디까지 수행했는지를 나타낸다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 &lt;strong&gt;어느 부분까지 수행했는지 기억할 필요가 있기 때문에 PC Register를 독립적으로 할당&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>